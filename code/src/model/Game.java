package model;//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Szoftver projekt laboratórium: Sivatagi vízhálózat
//  @ File Name : Model.Game.java
//  @ Date : 2023. 03. 28.
//  @ Author : aD4B team
//
//


import model.characters.Character;
import model.characters.Plumber;
import model.characters.Saboteur;
import model.fields.Cistern;
import model.fields.Pipe;
import model.fields.Pump;
import model.fields.WaterSource;
import org.apache.logging.log4j.Logger;
import proto.LogHelper;

import java.util.ArrayList;

/**
 * Játékot inicializáló singleton osztály.
 */
public class Game {
    private static final Logger LOGGER = LogHelper.getLogger();


    private static Game single_instance = null;    //Singleton típusú single_instance statikus változó referenciája

    private final ArrayList<Character> players = new ArrayList<>();        // Játékosok
    private final ArrayList<Steppable> steppables = new ArrayList<>();        //Léptethető elemek
    private final ArrayList<Pipe> pipes = new ArrayList<>();                    //Statikus elemek
    private final PlumberPointsObserver ppo = new PlumberPointsObserver();            //Szerelők pontját számoló observer
    private final SaboteurPointsObserver spo = new SaboteurPointsObserver();            //Szabotőrök pontját számoló observer

    private Character actCharacter;

    private int actRoundNumber = 1;

    private boolean trueBOOL=false;
    private boolean falseBOOL=false;

    /**
     * Statikus módszer a Singleton osztály példányának létrehozására és lekérésére
     * Ha nincs még létrehozva játék akkor ez létrehoz egyet 2-2 játékossal.
     *
     * @return Singleton Game osztály
     */
    public static synchronized Game getInstance() {
        if (single_instance == null)
            initGame(2, 2);

        return single_instance;
    }

    /**
     * Singleton biztosítása
     */
    private Game(){}

    /**
     * Létrehoz egy teljesen üres, inicializálatlan játékot.
     */
    public static synchronized void getNullGame() {
        single_instance = new Game();
    }

    /**x
     * Játék létrehozása megadott paraméterek szerint.
     *
     * @param numOfPlumbers  Szerelő játékosok száma.
     * @param numOfSaboteurs Szabotőr játékosok száma.
     */
    public static void initGame(int numOfPlumbers, int numOfSaboteurs) {
        single_instance = new Game();
        LOGGER.info("Új játék létrehozása...");


        //----------------watersource létrehozás---------------------
        WaterSource w1 = new WaterSource();    //Vízforrás létrehozása
        single_instance.steppables.add(w1);

        WaterSource w2 = new WaterSource();    //Vízforrás létrehozása
        single_instance.steppables.add(w2);

        WaterSource w3 = new WaterSource();    //Vízforrás létrehozása
        single_instance.steppables.add(w3);

        //----------------cistern létrehozás---------------------
        Cistern c1 = new Cistern();        //Ciszterna létrehozása
        single_instance.steppables.add(c1);
        c1.registerObserver(single_instance.ppo);    //Ciszternán observer regisztrálása

        Cistern c2 = new Cistern();        //Ciszterna létrehozása
        single_instance.steppables.add(c2);
        c2.registerObserver(single_instance.ppo);    //Ciszternán observer regisztrálása

        //----------------pump létrehozás---------------------
        Pump pump1 = new Pump();            //Egy pumpa létrehozása
        single_instance.steppables.add(pump1);

        Pump pump2 = new Pump();            //Egy pumpa létrehozása
        single_instance.steppables.add(pump2);

        Pump pump3 = new Pump();            //Egy pumpa létrehozása
        single_instance.steppables.add(pump3);

        Pump pump4 = new Pump();            //Egy pumpa létrehozása
        single_instance.steppables.add(pump4);

        //----------------pipe létrehozás, bekötés---------------------
        Pipe pipe1 = new Pipe(pump1, w1);            //pipe1 cső létrehozása
        single_instance.pipes.add(pipe1);
        pipe1.registerObserver(single_instance.spo);    //pipe1 csövön observer regisztrálása

        Pipe pipe2 = new Pipe(pump1, pump2);            //pipe2 cső létrehozása
        single_instance.pipes.add(pipe2);
        pipe2.registerObserver(single_instance.spo);    //pipe1 csövön observer regisztrálása

        Pipe pipe3 = new Pipe(pump2, c1);            //pipe2 cső létrehozása
        single_instance.pipes.add(pipe3);
        pipe3.registerObserver(single_instance.spo);    //pipe1 csövön observer regisztrálása

        Pipe pipe4 = new Pipe(pump3, c1);            //pipe2 cső létrehozása
        single_instance.pipes.add(pipe4);
        pipe4.registerObserver(single_instance.spo);    //pipe1 csövön observer regisztrálása

        Pipe pipe5 = new Pipe(pump3, null);            //pipe2 cső létrehozása
        single_instance.pipes.add(pipe5);
        pipe5.registerObserver(single_instance.spo);    //pipe1 csövön observer regisztrálása

        Pipe pipe6 = new Pipe(pump3, null);            //pipe2 cső létrehozása
        single_instance.pipes.add(pipe6);
        pipe6.registerObserver(single_instance.spo);    //pipe1 csövön observer regisztrálása

        Pipe pipe7 = new Pipe(pump3, w3);            //pipe2 cső létrehozása
        single_instance.pipes.add(pipe7);
        pipe7.registerObserver(single_instance.spo);    //pipe1 csövön observer regisztrálása

        Pipe pipe8 = new Pipe(pump3, null);            //pipe2 cső létrehozása
        single_instance.pipes.add(pipe8);
        pipe8.registerObserver(single_instance.spo);    //pipe1 csövön observer regisztrálása

        Pipe pipe9 = new Pipe(w3, null);            //pipe2 cső létrehozása
        single_instance.pipes.add(pipe9);
        pipe9.registerObserver(single_instance.spo);    //pipe1 csövön observer regisztrálása

        Pipe pipe10 = new Pipe(pump1, pump4);            //pipe2 cső létrehozása
        single_instance.pipes.add(pipe10);
        pipe10.registerObserver(single_instance.spo);    //pipe1 csövön observer regisztrálása

        Pipe pipe11 = new Pipe(pump4, w2);            //pipe2 cső létrehozása
        single_instance.pipes.add(pipe11);
        pipe11.registerObserver(single_instance.spo);    //pipe1 csövön observer regisztrálása

        Pipe pipe12 = new Pipe(pump4, pump2);            //pipe2 cső létrehozása
        single_instance.pipes.add(pipe12);
        pipe12.registerObserver(single_instance.spo);    //pipe1 csövön observer regisztrálása

        Pipe pipe13 = new Pipe(pump4, c2);            //pipe2 cső létrehozása
        single_instance.pipes.add(pipe13);
        pipe13.registerObserver(single_instance.spo);    //pipe1 csövön observer regisztrálása

        Pipe pipe14 = new Pipe(pump4, null);            //pipe2 cső létrehozása
        single_instance.pipes.add(pipe14);
        pipe14.registerObserver(single_instance.spo);    //pipe1 csövön observer regisztrálása

        //----------------watersource output beállítás---------------------
        w1.setOutput(pipe1);
        w2.setOutput(pipe11);
        w3.setOutput(pipe9);
        w3.setOutput(pipe7);

        //----------------cistern input beállítás---------------------
        c1.setInput(pipe3);
        c1.setInput(pipe4);
        c2.setInput(pipe13);

        //----------------pump in/output és neighbours beállítás---------------------
        pump1.setInput(pipe1);                //pipe1 cső beállítása a pumpa bemenetének
        pump1.setOutput(pipe2);            //pipe2 cső beállítása a pumpa kimenetének
        pump1.addNeighbourField(pipe10);

        pump2.setInput(pipe2);                //pipe1 cső beállítása a pumpa bemenetének
        pump2.setOutput(pipe3);            //pipe2 cső beállítása a pumpa kimenetének
        pump2.addNeighbourField(pipe12);

        pump3.setInput(pipe6);                //pipe1 cső beállítása a pumpa bemenetének
        pump3.setOutput(pipe4);            //pipe2 cső beállítása a pumpa kimenetének
        pump3.addNeighbourField(pipe5);
        pump3.addNeighbourField(pipe7);
        pump3.addNeighbourField(pipe8);

        pump4.setInput(pipe11);                //pipe1 cső beállítása a pumpa bemenetének
        pump4.setOutput(pipe14);            //pipe2 cső beállítása a pumpa kimenetének
        pump4.addNeighbourField(pipe10);
        pump4.addNeighbourField(pipe12);
        pump4.addNeighbourField(pipe13);

        //Plumber-ek létrehozása és ráhelyezése a pump1 Pumpára
        for (int i = 0; i < numOfPlumbers; i++) {
            if(i % 2 == 0) single_instance.players.add(new Plumber(c1));
            else single_instance.players.add(new Plumber(c2));
        }
        //Saboteur-ok létrehozása és ráhelyezése a pump1 Pumpára
        for (int i = 0; i < numOfSaboteurs; i++) {
            if(i % 2 == 0) single_instance.players.add(new Saboteur(w1));
            else single_instance.players.add(new Saboteur(w2));
        }

        single_instance.actCharacter = single_instance.players.get(0);
        System.out.println("Játék létrehozva "+(numOfSaboteurs+numOfPlumbers)+" játékossal.");
        LOGGER.info("Játék létrehozva!");
    }


    /**
     * Minden steppable elemre meghívja kétszer a step metódust
     */
    private void stepAllTwice() {
        for (int i = 0; i < 2; i++)
            for (Steppable s : steppables) {
                LOGGER.debug("A [{}] léptetése.", s);
                s.step();
            }
    }

    /**
     * Minden steppable elemre meghívja kétszer a step metódust
     */
    private void elapseRoundOnPipes() {
            for (Pipe p : pipes) {
                LOGGER.debug("Kör vége jelzés a [{}] elemen.", p);
                p.elapseRound();
            }
    }

    /**
     * A steppables attribútumához adja a paraméterben megadott Steppable objektumot
     *
     * @param s Steppables-hez adni kívánt objektum
     */
    public void addSteppable(Steppable s) {
        steppables.add(s);
    }

    /**
     * A pipes attribútumához adja a paraméterben megadott Pipe objektumot
     *
     * @param p Pipe-hoz adni kívánt objektum
     */
    public void addPipe(Pipe p) {
        pipes.add(p);
    }

    /**
     * Visszatér a következő játékossal. Ha megint az első játékos következne akkor számol egy kört.
     */
    public void nextCharacter() {
        LOGGER.debug("Végzett játékos: [{}]", actCharacter);
        actCharacter.elapseRound();     //Jelezzük neki, hogy már más következik

        int actCharIndex = players.indexOf(actCharacter);   //Kérjük le az indexét, hogy tudjuk nézni a következőt
        if (players.size() > actCharIndex + 1) actCharacter = players.get(actCharIndex + 1);
        else {
            System.out.println("Vége a(z) " + actRoundNumber + ". körnek!");
            LOGGER.debug("{}. kör vége.", actRoundNumber);
            actRoundNumber++;   //Lefutott egy kör!

            //Léptessük az elemeket
            stepAllTwice();
            elapseRoundOnPipes();

            //KKezdjük megint a 0. játékossal
            actCharacter = players.get(0);
            LOGGER.debug("{}. kör elkezdődik.", actRoundNumber);
        }
        LOGGER.debug("Következő játékos: [{}]", actCharacter);
    }

    /**
     * Lekérdezi, hogy véget ért-e már a játék.
     *
     * @return játék vége
     */
    public boolean isGameOver() {
        return actRoundNumber >= 10;
    }

    /**
     * SaboteurPointsObserver lekérdezése
     *
     * @return visszatér a játék mindenkori SaboteurPointsObserver-ével
     */
    public SaboteurPointsObserver getSpo() {
        return spo;
    }

    /**
     * PlumberPointsObserver lekérdezése
     *
     * @return visszatér a játék mindenkori PlumberPointsObserver-ével
     */
    public PlumberPointsObserver getPpo() {
        return ppo;
    }

    /**
     * aktuális karakter lekérdezése
     *
     * @return az aktuális karakter
     */
    public Character getActCharacter() {
        return actCharacter;
    }

    /**
     * beállítja az aktuálisan jövő játékost
     *
     * @param c a karakter, aki az aktuális lesz
     */
    public void setActCharacter(Character c) {
        actCharacter = c;
    }

    /**
     * hozzáad egy karaktert
     *
     * @param c a karakter
     */
    public void addCharacter(Character c) {
        players.add(c);
    }

    /**
     * Tesztek futtatásához beállítható "IGAZ/HAMIS" paraméter
     * @param choice a beállítani kívánt érték
     */
    public void testHelper (boolean choice) {
        if (choice) trueBOOL = true;
        else falseBOOL = true;
    }

    /**
     * Teszteléshez a "HAMIS" érték lekérdezése
     * @return beállítottsága
     */
    public boolean isFalseBOOL() {
        return falseBOOL;
    }
    /**
     * Teszteléshez az "IGAZ" érték lekérdezése
     * @return beállítottsága
     */
    public boolean isTrueBOOL(){return trueBOOL;
    }

    /**
     * Léptethető dolgokat adja vissza
     * @return STEPPABLE tömbje
     */
    public ArrayList<Steppable> getSteppables(){
        return steppables;
    }

    /**
     * Csövek listáját adja át
     * @return CSÖVEK tömbje
     */
    public ArrayList<Pipe> getPipes(){
        return pipes;
    }

    /**
     * Karaktereket adja vissza
     * @return KARAKTER tömb
     */
    public ArrayList<Character> getPlayers(){
        return players;
    }

    /**
     * Cső eltávolítása
     * @param pipe eltávolítani kívánt cső
     */
    public void removePipe(Pipe pipe) {
        pipes.remove(pipe);
    }
}
