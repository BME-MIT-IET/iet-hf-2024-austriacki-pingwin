package model.fields;//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Szoftver projekt laboratórium: Sivatagi vízhálózat
//  @ File Name : Model.ActiveField.java
//  @ Date : 2023. 03. 28.
//  @ Author : aD4B team
//
//


import model.Steppable;
import org.apache.logging.log4j.Logger;
import proto.LogHelper;

import java.util.ArrayList;

/**
 * Aktív elemeket (csomópontokat) összefogó absztrakt osztály
 */
public abstract class ActiveField extends Field implements Steppable {
    private static final Logger LOGGER = LogHelper.getLogger();
    protected final ArrayList<Pipe> neighbourFields=new ArrayList<>();     //szomszédos (csatlakozó) csövek


    /**
     * Absztrakt metódus.
     */
    public abstract void step();

    /**
     * A mező kiválasztott szomszédját „lecsatlakoztatja”
     * róla vagy, ha van szabad vége a kiválasztott elemnek akkor az kerül a játékoshoz.
     *
     * @param pipe Felvenni kívánt cső
     */
    @Override
    public void pickUpPipe(Pipe pipe) {
        if (pipe == null || !neighbourFields.contains(pipe)) {
            try{
                LOGGER.debug("A megadott cső (" + pipe + ") nem szomszédja az ActiveField-nek (" + this + ")");
            } catch(NullPointerException e){ //ha nulla lenne a kapott cső, toString exceptiont dob
                LOGGER.debug("A megadott cső null, így nem szomszédja az ActiveField-nek (" + this + ")");
            }
            return;
        }
        pipe.disconnectFrom(this);
        pipe.incPickedUpCounter();
    }

    /**
     * A mezőhöz csatlakoztatja a paraméteben kapott mezőt.
     *
     * @param newPipe Csatlakoztatni kívánt cső
     * @return Csatlakozás sikeressége
     */
    @Override
    public boolean placeDownPipe(Pipe newPipe) {
        for(Pipe p:neighbourFields){
            if( p==newPipe){
                LOGGER.info("SIKERTELEN - nem sikerült lerakni a csövet.");
                LOGGER.debug("A cső egyik vége már be van kötve ehhez az elemhez");
                return false;
            }
        }
        if (newPipe != null && (neighbourFields.size() != maxNeighbours)) {
            //Csőduplázás elkerüléséhez vizsgálat
            if(newPipe.getNeighbours().size()>0&&newPipe.getNeighbours().get(0)!=null) {
                ActiveField newPipeNeighbour = newPipe.getNeighbours().get(0);
                ActiveField thisPneighbourfield;
                if(newPipeNeighbour!=null){
                    for(Pipe p:neighbourFields){ //Ha bármelyik csövének azonos a másik szomszédja a csőnek, amit rá akarunk kötni, akkor nem megy végbe
                        if(p.getNeighbours().size()>0&&p.getNeighbours().get(0)!=null){
                            if((thisPneighbourfield=p.getNeighbours().get(0))==this){
                                if(p.getNeighbours().size()>1 && p.getNeighbours().get(1)!=null){
                                    thisPneighbourfield=p.getNeighbours().get(1);
                                }
                            }
                            if(newPipeNeighbour==thisPneighbourfield){
                                LOGGER.info("SIKERTELEN - nem sikerült lerakni a csövet.");
                                LOGGER.debug("Olyan elemmel kötné össze a lehelyezni kívánt cső "+this+"ezt elemünket, amivel már egy másik cső összeköti!");
                                return false;
                            }
                        }
                    }
                }
            }
            //A lehelyezni kívánt cső átment a "teszten" és új elemmel köti össze
            neighbourFields.add(newPipe);
            newPipe.connectTo(this);
            newPipe.decPickedUpCounter();
            LOGGER.info("SIKERES - sikerült lerakni a csövet.");
            LOGGER.debug("neighbourFields-be bekerült a : " + newPipe);
            return true;
        } else {
            LOGGER.info("SIKERTELEN - nem sikerült lerakni a csövet.");
            LOGGER.debug("Tele van az elem (karakterben is vizsgáljuk a cső nullaságát)");
            return false;
        }
    }


    /**
     * Kicseréli a oldPipe-el megadott (szomszédos) csövet a newPipe-ben megadott csőre.
     *
     * @param oldPipe Ezt az elemet akarjuk lecserléni.
     * @param newPipe Erre az elemre akarjuk lecserélni.
     */
    public void replacePipe(Pipe oldPipe, Pipe newPipe) {
        if (oldPipe == null || newPipe == null) {
            LOGGER.warn("Hibás replacePipe hívás!");
            return;
        }
        int idx = neighbourFields.indexOf(oldPipe);  //Keressük meg a listában a oldPipe csövet
        LOGGER.debug("oldPipe indexe = {}", idx);
        neighbourFields.set(idx, newPipe);   //Cseréljük le newPipe-re
        LOGGER.info("A \"{}\" cső sikeresen lecserélve \"{}\" csőre!", oldPipe.toString(), newPipe.toString());
    }

    /**
     * Leszármazottakban override-olt függvény, alapértelmezetten nem csinál semmit.
     *
     * @param pipe Bemeneti cső
     */
    public void setInput(Pipe pipe) {
        LOGGER.warn("Nem állítható be inputnak a {}", pipe.toString());
    }

    /**
     * Leszármazottakban override-olt függvény, alapértelmezetten nem csinál semmit.
     *
     * @param pipe Kimeneti cső
     */
    public void setOutput(Pipe pipe) {
        LOGGER.warn("Nem állítható be outputnak a {}", pipe.toString());
    }


    /**
     * hozzáadja a paraméterben kapott Pipe-ot a neighbourFields attribútumához.
     *
     * @param pipe Hozzáadni kívánt cső
     */
    public void addNeighbourField(Pipe pipe) {
        neighbourFields.add(pipe);
        LOGGER.debug("cső hozzáadva a szomszédjaihoz\tneighbourFields-be bekerült a : " + pipe.toString());
    }

    public void removeNeighbourField(Pipe pipe){
        neighbourFields.remove(pipe);
        LOGGER.debug("cső kivéve a szomszédjaiból\tneighbourFields-ből kikerült a : " + pipe.toString());
    }

    /**
     * A mezőhöz csatlakozó szomszédos mezőket adja vissza.
     *
     * @return Szomszédos mezők
     */
    public ArrayList<Pipe> getNeighbours() {
        LOGGER.debug("szomszédok visszaadva");
        return neighbourFields;
    }

    /**
     * Visszaadja a mezőn alkalmazható műveletetek
     */
    public ArrayList<String> getCommands() {
        //a parancsok megadása string tömbben
        ArrayList<String> cmds = new ArrayList<>();
        cmds.add("pickupPipe");
        cmds.add("placedownPipe");
        return cmds;
    }

    /**
     * Visszaadja, hogy tele van-e a szomszédjainak a száma
     * @return igen ha tele van
     */
    public boolean isFull(){
        return neighbourFields.size() == 5;
    }

    /**
     * Visszaadja, hogy a mező elérte-e a maximum szomszédjainak a számát
     * @return Elérte e a max szomszédok számát
     */
    @Override
    public boolean hasMaxNeighbours(){
        return neighbourFields.size() >= maxNeighbours;
    }
}
