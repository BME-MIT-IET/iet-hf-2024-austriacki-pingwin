package model.fields;//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Szoftver projekt laboratórium: Sivatagi vízhálózat
//  @ File Name : Model.Cistern.java
//  @ Date : 2023. 03. 28.
//  @ Author : aD4B team
//
//


import model.CountableObserved;
import model.Game;
import model.Observer;
import org.apache.logging.log4j.Logger;
import proto.LogHelper;

import java.util.ArrayList;

/**
 * Olyan aktív elem, ahova a szerelőnek vizet kell juttatnia a csőhálózaton keresztül.
 * Folyamatosan létrehoz új csöveket, melyek egyik vége ehhez van csatlakoztatva. Itt
 * tudnak felvenni új pumpákat a szerelők. Felelőssége jelezni a CountObservernek az
 * összegyűlt vizet.
 */
public class Cistern extends ActiveField implements CountableObserved {
    private static final Logger LOGGER = LogHelper.getLogger();
    private final ArrayList<Observer> observers = new ArrayList<>();      //A megfigyelőinek listája.

    int pipeMakerCounter=0;

    /**
     * Konstruktor
     */
    public Cistern() {
        LOGGER.info("SIKERES ciszterna létrehozás");
    }

    @Override
    public String toString() {
        return "ID: " + super.toString() + " Szomszédok száma: " + neighbourFields.size();

    }

    /**
     * Ciszterna állapota
     *
     * @return állapotleírás
     */
    public String getStat() {
        return this.toString();
    }


    /**
     * Egy szerelőnek pumpát ad.
     *
     * @return Egy újonnan létrehozott pumpa
     */
    @Override
    public Pump givePump() {
        LOGGER.info("SIKERES pumpa átadás");
        return new Pump();
    }


    /**
     * Léptetésre néha új csövet hoz létre.
     */
    @Override
    public void step() {
        int fullRoundSize=Game.getInstance().getPlayers().size();
        if (maxNeighbours > neighbourFields.size()) {
            if(!Game.getInstance().isTrueBOOL() && !Game.getInstance().isFalseBOOL()){
                pipeMakerCounter++;
                if(pipeMakerCounter==fullRoundSize){
                    Pipe p = new Pipe();
                    neighbourFields.add(p);
                    p.connectTo(this);
                    p.registerObserver(Game.getInstance().getSpo());
                    Game.getInstance().addPipe(p);
                    LOGGER.debug("A ciszterna elkészített egy csövet "+ pipeMakerCounter+" idő alatt");
                    pipeMakerCounter=0;
                }
            }
            if(Game.getInstance().isTrueBOOL()){
                Pipe p = new Pipe();
                neighbourFields.add(p);
                p.connectTo(this);
                p.registerObserver(Game.getInstance().getSpo());
                Game.getInstance().addPipe(p);
                LOGGER.debug("A ciszterna csövet hozott létre a léptetésére!");
                isDamaged=true;
            }
            if(Game.getInstance().isFalseBOOL()){
                LOGGER.debug("A ciszterna nem hozott létre csövet a léptetésére!");
                isDamaged=false;
            }
        }
        LOGGER.info("SIKERES ciszterna léptetés");
    }

    /**
     * Kezeli, ha vizet kap, azaz szól az observerének.
     */
    @Override
    public int acceptWater(int water, Field fromField) {
        LOGGER.info(water + "_mennyíségű vizet kapott a ciszterna!");
        notifyObservers(water);
        return 0;
    }


    /**
     * Hozzáadja a paraméterben megadott csövet a bemeneti csövek listájához.
     */
    @Override
    public void setInput(Pipe pipe) {
        LOGGER.debug("Új bemenet került beállításra");
        if (!neighbourFields.contains(pipe))
            neighbourFields.add(pipe);
    }

    /**
     * Felveszi a megfigyelői közé a paraméterként átvett Observert.
     */
    @Override
    public void registerObserver(Observer obs) {
        LOGGER.debug("Új obszerver került beállításra");
        observers.add(obs);
    }

    /**
     * Törli az őt megfigyelő Observereket
     */
    @Override
    public void unregisterObservers() {
        LOGGER.debug("Obszerverek eltávolítva");
        observers.clear();
    }

    /**
     * Értesíti az őt megfigyelő Observereket
     *
     * @param water értesítendő érték
     */
    @Override
    public void notifyObservers(int water) {
        LOGGER.debug("Obszerverek értesítése");
        for (Observer obs : observers) {
            obs.update(water);
        }
    }

    /**
     * Visszaadja a mezőn alkalmazható műveletetek
     */
    @Override
    public ArrayList<String> getCommands() {
        //a parancsok megadása string tömbben
        ArrayList<String> cmds = new ArrayList<>(super.getCommands());
        cmds.add("pickupPump");
        return cmds;
    }
}
