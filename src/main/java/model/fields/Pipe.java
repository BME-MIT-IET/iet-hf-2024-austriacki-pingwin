package model.fields;//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Szoftver projekt laboratórium: Sivatagi vízhálózat
//  @ File Name : Model.Pipe.java
//  @ Date : 2023. 03. 28.
//  @ Author : aD4B team
//
//

import model.CountableObserved;
import model.Game;
import model.Observer;
import model.characters.Character;
import org.apache.logging.log4j.Logger;
import proto.LogHelper;

import java.util.ArrayList;
import java.util.Random;

/**
 * Csöveket reprezentáló osztály, a két szomszédos aktív eleme között felel a víz továbbítására.
 * Sérült cső esetén a sivatagba kerül a kapott folyadék, ilyenkor nem adja tovább a kimenetére,
 * jeleznie kell az Observernek az eseményt.
 */
public class Pipe extends Field implements CountableObserved {
    private static final Logger LOGGER = LogHelper.getLogger();

    private final ArrayList<ActiveField> activeFields = new ArrayList<>();    //szomszédos (csatlakozó) aktív elemek
    private final ArrayList<Observer> observers = new ArrayList<>();          //A megfigyelőinek listája.
    private int fluidLevel = 0;             //A csőben lévő folyadék mennyiségét jelzi.
    private int capacity = 3;
    private boolean isSticky = false;           //Ragadós csövet jelzi.
    private boolean isSlippery = false;         //Csúszós csövet jelzi.
    private int protectTimer = 0;           //Amíg a számláló nem 0, a csövet nem lehet kilyukasztani.
    private int pickedUpCounter = 0;        //Csőnek mennyi vége van lecsatlakoztatva.
    private Random random = new Random(); 

    /**
     * Konstruktor.
     */
    public Pipe() {
        maxCharacters = 1;
        LOGGER.info("SIKERES csőlétrehozás");
    }

    /**
     * A pipe paraméteres konstruktora
     * Beállítja a paraméterül kapott mezőket szomszédjaként
     */
    public Pipe(ActiveField neighbourField1, ActiveField neighbourField2) {
        this();     //Call default constructor
        if (neighbourField1 != null) activeFields.add(neighbourField1);
        if (neighbourField2 != null) activeFields.add(neighbourField2);
        LOGGER.debug("A létrehozott csőnek konstruktorban megadott csövek szomszédként be lettek állítva");
    }

    @Override
    public String toString() {
        return "ID: \"" + super.toString() + "\"";
    }


    /**
     * Pipe állapota
     *
     * @return állapotleírás
     */
    public String getStat() {
        return "ID: \"" + super.toString() + "\" Vízszint: \"" + fluidLevel + "\" isSticky: \"" + isSticky
                + "\" isSlippery: \"" + isSlippery + "\" isDamaged: \"" + isDamaged + "\" ProtectTimer: \"" + protectTimer
                + "\" pickedUpCounter: \"" + pickedUpCounter + "\" Szomszédok száma: \"" + activeFields.size() + "\"";
    }

    /**
     * A paraméterként kapott elemet elhelyezi a cső
     * közepén, annak „kettévágásával”.
     *
     * @param pump Lehelyezni kívánt pumpa
     */
    @Override
    public boolean placeDownPump(ActiveField pump) {
        //Új csődarabok létrehozása
        Pipe p1 = new Pipe();
        Pipe p2 = new Pipe();

        Game.getInstance().addPipe(p1);
        Game.getInstance().addPipe(p2);
        Game.getInstance().removePipe(this);

        p1.connectTo(pump);
        p2.connectTo(pump);
        p1.connectTo(activeFields.get(0));
        if(activeFields.size()>1) p2.connectTo(activeFields.get(1));

        //Obszerverek regisztrálása
        for (Observer o : observers) {
            p1.registerObserver(o);
            p2.registerObserver(o);
        }

        //Csatlakozás kicserélése
        activeFields.get(0).replacePipe(this, p1);
        if(activeFields.size()>1) activeFields.get(1).replacePipe(this, p2);

        //Pumpán beállítjuk a létrehozott csöveket
        pump.settedPump(p1, p2);

        activeFields.clear();

        LOGGER.info("SIKERES pumpalehelyezés"); //minden debug infó a hívott függvényekben
        return true;
    }

    /**
     * Az ősosztály isDamaged attribútumát true-ra javítja, azaz
     * „meghibásítja”.
     *
     * @return meghibásítás sikeressége
     */
    @Override
    public boolean damagedPipe() {

        boolean oldIsDamaged = isDamaged;
        if (protectTimer <= 0) {
            isDamaged = true;
            if (fluidLevel > 0) { //Benne lévő víz elfolyik
                notifyObservers(fluidLevel);
                fluidLevel = 0;
                LOGGER.debug("A cső lyukasztás hatására elfolyatta a benne rekedt vizet");
            }

            LOGGER.info("SIKERES csőlyukasztás");
            return !oldIsDamaged;   //Ha alaból is true volt akkor false legyen a visszatérés
        } else {
            LOGGER.info("SIKERTELEN csőlyukasztás, a cső védett");
            LOGGER.debug("ProtectTimer: " + protectTimer);
            return false;
        }
    }

    /**
     * Játékost a mezőre helyezi, amennyiben más játékos nem áll a csövön és nem csúszós a cső.
     * Csúszós cső esetén egy véletlenszerűen kiválasztott szomszédos elemre kerül a játékos.
     * Ragadós cső esetén „lefagyasztja” a rálépő Character-t.
     * Sikeres művelet esetén visszatérési értéke az a mező, amelyre a játékos került, sikertelen lépés esetén null.
     *
     * @param ch játékos
     * @return mező, amelyre a játékos került
     */
    @Override
    public Field acceptCharacter(Character ch) {
        if (characters.size() < maxCharacters) {
            //Ha ragacsos akkor fagyasszuk le
            if (isSticky) {
                LOGGER.debug("A karakter ragadós csőre lépett");
                ch.glue(2);
                isSticky = false;
            }
            //Ha csúszós akkor véletlenszerűen válasszunk szomszédot és rakjuk át oda
            if (isSlippery) {
                LOGGER.debug("A karakter csúszós csőre lépett");
                isSlippery = false;
                this.random.nextInt(activeFields.size());
                if (Game.getInstance().isFalseBOOL()) {
                    if (activeFields.get(0) == ch.getActField()) {
                        LOGGER.debug("A karakter visszakerült oda ahonnan indult!");
                        return activeFields.get(0).acceptCharacter(ch);
                    } else {
                        LOGGER.debug("A karakter visszakerült oda ahonnan indult!");
                        return activeFields.get(1).acceptCharacter(ch);
                    }
                }
                if (Game.getInstance().isTrueBOOL()) {
                    if (activeFields.get(0) == ch.getActField()) {
                        LOGGER.debug("A karakter a cső túloldalára került!");
                        return activeFields.get(1).acceptCharacter(ch);
                    } else {
                        LOGGER.debug("A karakter a cső túloldalára került!");
                        return activeFields.get(0).acceptCharacter(ch);
                    }
                }
                if (activeFields.get(random) != null) {
                    LOGGER.debug("A karakter a csúszós cső egyik oldalára került");
                    return activeFields.get(random).acceptCharacter(ch);
                }
            } else {
                characters.add(ch);
                LOGGER.info("SIKERES csőre lépés");
                return this;
            }
        }
        LOGGER.info("SIKERTELEN csőre lépés");
        LOGGER.debug("A cső foglalt volt");
        return null;
    }

    /**
     * Kezeli, ha vizet kap, hogy belefér-e, illetve továbbadja
     * a maximum mennyiséget, amit tud, a fennmaradó víz mennyiségével tér vissza.
     */
    public int acceptWater(int water, Field fromField) {
        int remainder;
        if (isDamaged) {        //Hibás cső esetén kifolyik a sivatagba
            LOGGER.debug("A cső lyukas volt, elfolyik a víz");
            remainder = 0;
            notifyObservers(water);
        } else {
            fluidLevel += water;
            LOGGER.debug("A víz hozzáadásra került a csőhöz");
            //A cső maximális befogadóképességét jelzi.
            int capacity = 5;
            if (fluidLevel > capacity) {   //Ha túlcsordulna
                remainder = fluidLevel - capacity;
                LOGGER.debug("Nem fért bele az összes víz, vízszint maximumra állítva, maradék visszaadása");
                fluidLevel = capacity;
            } else {
                remainder = 0;
                LOGGER.debug("Minden víz belefért");
            }

            //Adjuk tovább az aktív elemnek a vizet, ha van csatlakoztatva
            if (activeFields.size() >= 2 && !activeFields.contains(null)) {
                if (activeFields.get(0) == fromField) {
                    fluidLevel = activeFields.get(1).acceptWater(fluidLevel, this);
                    LOGGER.debug("Víz továbbadása a következő elemnek");
                } else {
                    fluidLevel = activeFields.get(0).acceptWater(fluidLevel, this);
                    LOGGER.debug("Víz továbbadása a következő elemnek");
                }
            } else if (activeFields.size() == 1 && activeFields.get(0) == fromField) { //Ha csak 1 szomszédja van akitől kapta a vizet->elfolyik sivatagba
                remainder = 0;
                notifyObservers(water);
                LOGGER.debug("Víz elfolyatása, nem volt máshoz csatlakoztatva a cső");
            }
        }
        LOGGER.info("SIKERES a cső vízelfogadása");
        return remainder;
    }

    /**
     * Cső hozzácsatlakoztatása a paraméterben megadott Field-hez.
     *
     * @param activeField csatlakoztatni kívánt mező
     */
    public void connectTo(ActiveField activeField) {
        LOGGER.debug("A cső csatlakoztatva lett: " + activeField.toString() + " -hez");
        activeFields.add(activeField);
    }

    /**
     * Lecsatlakoztatja a csövet:
     * 2 szomszéd esetén a megadott fromField-ről
     * 1 szomszéd esetén nem kell lecsatlakoztatni
     *
     * @param fromField Az a Field, amely meghívta a függvényt.
     */
    public void disconnectFrom(ActiveField fromField) {
        if (activeFields.size() >= 2 || pickedUpCounter == 1) {
            activeFields.remove(fromField);  //csatlakoztassuk le az átadott ActiveField-et
            fromField.removeNeighbourField(this); //vegyük ki a csövet a meghívott field szomszédjaiból
            LOGGER.info("SIKERES csőlecsatlakoztatás");
        } else LOGGER.info("A cső egyik vége sem lett lecsatlakoztatva (1 helyre volt bekötve és nincs senkinél a másik vége.)");
    }

    /**
     * Ősosztály fixed metódusát hívja,
     * majd a protectTimer-t beállítja, így egy ideig nem lyukasztható ki újra a cső.
     *
     * @return javítás sikeressége.
     */
    @Override
    public boolean fixed() {
        //Ha fel van véve a cső, nem helyezhetünk le pumpát
        if(pickedUpCounter>0) return false;

        boolean canFix = super.fixed();
        if (canFix) protectTimer = 10;
        LOGGER.info("SIKERES csőjavítás");
        LOGGER.debug("A cső " + protectTimer + " ideig védett");
        return canFix;
    }

    /**
     * Csúszóssá teszi a csövet, így aki rálép, véletlenszerűen a cső valamelyik végéhez kapcsolódó elemre kerül.
     *
     * @return Ha alapból is csúszós volt a cső akkor false, különben true
     */
    @Override
    public boolean makeSlippery() {
        if (isSlippery) {
            LOGGER.info("SIKERTELEN a cső már csúszós");
            return false;
        }
        LOGGER.info("SIKERES a cső csúszós lett");
        return isSlippery = true;
    }

    /**
     * Ragadóssá teszi a csövet, így aki rálép, véletlenszerűen a cső valamelyik végéhez kapcsolódó elemre kerül.
     *
     * @return Ha alapból is ragadós volt a cső akkor false, különben true
     */
    @Override
    public boolean makeSticky() {
        if (isSticky) {
            LOGGER.info("SIKERTELEN a cső már ragadós");
            return false;
        }
        LOGGER.info("SIKERES a cső ragadós lett");
        return isSticky = true;
    }


    /**
     * A mezőhöz csatlakozó szomszédos mezőket adja vissza.
     *
     * @return Szomszédos mezők
     */
    public ArrayList<ActiveField> getNeighbours() {
        LOGGER.debug("Cső szomszédjainak visszaadása");
        return activeFields;
    }

    /**
     * Növeli 1-el a pickedUpCounter attribútum értékét.
     */
    protected void incPickedUpCounter() {
        LOGGER.debug("Cső 'pickedUpCounter' növelése: " + pickedUpCounter + "+1");
        pickedUpCounter++;
    }

    /**
     * Csökketni 1-el a pickedUpCounter attribútum értékét.
     */
    protected void decPickedUpCounter() {
        LOGGER.debug("Cső 'pickedUpCounter' csökkentése: " + pickedUpCounter + "-1");
        pickedUpCounter--;
    }

    /**
     * Visszatér a csőben lévő vízmennyiséggel.
     *
     * @return vízszint
     */
    public int getFluidLevel() {
        LOGGER.debug("Cső 'fluidLevel' visszaadása:" + fluidLevel);
        return fluidLevel;
    }

    /**
     * Visszatér a cső vízkapacitásával.
     *
     * @return maximális vízszint
     */
    public int getFluidCapacity() {
        return capacity;
    }

    /**
     * Beállítja a fluidLevel attribútum értékét a paraméterben megadott mennyiségre.
     *
     * @param w vízmennyiség értéke
     */
    public void setFluidLevel(int w) {
        LOGGER.debug("Cső 'fluidLevel' beállítása:" + fluidLevel);
        fluidLevel = w;
    }

    /**
     * A paraméterként kapott observert felveszi az értesítési listájára.
     *
     * @param o beállítani kívánt Observer
     */
    @Override
    public void registerObserver(Observer o) {
        LOGGER.debug("Cső observer beállítása");
        observers.add(o);
    }

    /**
     * Törli az őt megfigyelő Observereket
     */
    @Override
    public void unregisterObservers() {
        LOGGER.debug("Cső observer eltávolítása");
        observers.clear();
    }

    /**
     * Értesíti az őt megfigyelő Observereket
     *
     * @param water vízmennyiség értéke, amivel értesítjük az Observereket
     */
    @Override
    public void notifyObservers(int water) {
        LOGGER.debug("Cső observereinek értesítése " + water + " értékkel");
        for (Observer obs : observers)
            obs.update(water);
    }

    /**
     * Visszaadja a mezőn alkalmazható műveletetek
     */
    public ArrayList<String> getCommands() {
        //a parancsok megadása string tömbben
        ArrayList<String> cmds = new ArrayList<>();
        cmds.add("fix");
        cmds.add("damage");
        cmds.add("placedownPump");
        cmds.add("sticky");
        cmds.add("slippery"); //csak saboteur esetén
        return cmds;
    }

    /**
     * Csökkenti a protecTimer értékét.
     */
    public void elapseRound() {
        if (protectTimer > 0) {
            protectTimer--;
            LOGGER.info("A protecTimer értéke csökkentve!");
            LOGGER.debug("A [{}] cső protecTimer értéke [{}]", this, protectTimer);
        }
    }

    /**
     * Visszatér a másik szomszédjával.
     *
     * @param notThis Az a szomszéd, amelyik nem kell
     * @return A szomszéd, amelyik kell
     */
    public ActiveField getOtherNeighbour(ActiveField notThis) {
        if (activeFields.size() >= 2) {
            if (activeFields.get(0) == notThis) return activeFields.get(1);
            else if (activeFields.get(1) == notThis) return activeFields.get(0);
        }
        return null;
    }

    /**
     * Visszaadja, hogy egy cső csúszós-e
     * @return Csúszós-e a cső
     */
    @Override
    public boolean isSlippery(){
        return isSlippery;
    }

    /**
     * Visszaadja, hogy egy cső ragadós-e
     * @return Ragadós-e a cső
     */
    @Override
    public boolean isSticky(){
        return isSticky;
    }

    /**
     *Visszaadja, hogy fel van-e véve a cső
     * @return Fel van-e véve a cső
     */
    @Override
    public boolean isPickedUp(){
        return pickedUpCounter>0;
    }
}
